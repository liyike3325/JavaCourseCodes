# 总结
## JVM
### 堆内存
堆内存分为年轻代和老年代，年轻代分为Eden区、存活区s0、存活区s1  
新对象分配在Eden区，标记阶段Eden区存活的对象就会复制到存活区，对象存活到一定周期会提升到老年代
堆内存越大GC次数越少，但是GC时间会更长
需要保持-Xmx和-Xms一致，否则应用刚启动可能就有好几个FullGC。当两者不一致时，堆内存扩容可能会导致性能抖动
### GC
串行GC：单线程垃圾收集器，不能进行并行处理。只适合几百MB堆内存的JVM，而且是单核CPU时比较有用
并行GC：适用于多核服务器，主要目标是增加吞吐量。在GC期间，所有CPU内核都在并行清理垃圾，所以总暂停时间更短
CMS GC：没有明显的应用线程暂停，但会和应用线程争抢CPU时，主要调优目标是降低GC停顿导致的系统延迟
G1 GC：一款实时垃圾收集器，可设置某项特定性能指标，以达到可预期停顿时间

## NIO
### I/O模型
阻塞式I/O：进行I/O的时候会暂停进程，在等待的数据没到达之前进程不会执行
非阻塞式I/O：进行I/O的时候进程还可以继续执行，比如可以运行其他的任务
基于信号的I/O：在I/O执行的数据准备阶段，不需要轮询，数据准备好后发给用户进程一个信号
I/O多路复用：操作系统代替应用程序做轮询，多个I/O合用一个阻塞式接口
异步I/O：真正实现了I/O全流程非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程I/O操作执行完毕
### Netty
Netty中的Channel是框架自己定义的一个通道接口，Netty实现的客户端NIO套接字通道是NioSocketChannel，提供的服务端NIO套接字通道是NioServerSocketChannel  
当服务端和客户端建立一个新的连接时，一个新的Channel将被创建，同时它会自动地分配到它专属的ChannelPipeline  
ChannelHandler分为ChannelInBoundHandler和ChannelOutboundHandler两种，如果一个入站IO事件被触发，这个事件会从第一个开始依次通过ChannelPipeline中的ChannelInBoundHandler，先添加的先执行  
若是一个出站I/O事件，则会从最后一个开始依次通过ChannelPipeline中的ChannelOutboundHandler，后添加的先执行  

## 并发编程
原子性：对基本数据类型变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行  
可见性：对于可见性，java提供了volatile关键字来保证可见性  
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值  
另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中  
volatile并不能保证原子性  
有序性：java允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性  

## Spring和ORM等框架
spring aop：加一个中间层代理实现对象托管  
ioc-控制反转：依赖注入，可以实现不修改代码，修改配置文件，即可运行时替换成另一实现类  
spring boot：是spring的一套快速配置脚手架，关注自动配置，配置驱动  
jdbc：定义了数据库交互接口  
数据库连接池：Druid、Hikari  
ORM：Hibernate、MyBatis、JPA  
MyBatis优点：原声SQL（XML语法），直观，对DBA友好  
Hibernate优点：简单场景不用写SQL  
Mybatis缺点：繁琐，可以用MyBatis-generator、MyBatis-Plus之类的插件  
Hibernate缺点：对DBA不友好

## MySQL数据库和SQL
写一个java程序插入100万订单数据，单条sql插入速度慢，多条sql批量插入，不自动提交数据，而是最后全部插入完后统一commit，这样速度快  
MySQL InnoDB使用了B+树索引模型。索引类型有主键索引和非主键索引，非主键索引需要回表多扫描一棵索引树。主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。从性能和存储空间考量，自增主键往往是更合理的选择。业务字段做主键的场景：1.只有一个索引 2.该索引必须是唯一索引  

## 分库分表
主从结构解决了高可用，读扩展，但是单机容量不变，单机写性能无法解决  
分库分表，分布式，多个数据库，作为数据分片的集群提供服务。降低单个节点写压力。提升整个系统的数据容量上限  
垂直拆分：将一个数据库，拆分成多个提供不同业务数据处理能力的数据库  
水平拆分：直接对数据进行分片，有分库和分表两个具体方式，但是都只是降低单个节点数据量，但不改变数据本身的结构。这样对业务系统本身的代码逻辑来说，就不需要做特别大的改动，甚至可以基于一些中间件做到透明  

## RPC和微服务
RPC是远程过程调用（Remote Procedure Call）的缩写形式。RPC就是像调用本地方法一样调用远程方法
RPC原理：1.本地代理存根Stub 2.本地序列化反序列化 3.网络通信 4.远程序列化反序列化 5.远程服务存根Skeleton 6.调用世纪业务服务 7.原路返回服务结果 8.返回给本地调用方  
分布式业务场景需要考虑：1.多个相同服务如何管理 2.服务的注册发现机制 3.如何负载均衡，路由等集群功能 4.熔断，限流等治理能力 5.心跳，重试等策略 6.高可用、监控、性能等  
分布式服务化：直接调用，侧边增强  
RPC之上的增强能力根据特点：1.有状态的部分，放到xx中心 2.无状态的部分，放到应用侧（具体来说是框架和配置部分，尽量不影响业务代码）  

## 分布式缓存
缓存的本质：系统各级处理速度不匹配，导致利用空间换时间  
缓存是提升系统性能的一个简单有效的办法  
变动频率大、一致性要求高的数据，不太适合用缓存  
本地缓存缺点：1.在多个集群环境同步，当集群规模增大，缓存的读写放大 2.在JVM中长期占用内存，如果是堆内存，总是会影响GC 3.缓存数据的调度处理，影响执行业务的线程，抢资源  

缓存穿透：大量并发查询不存在的KEY，导致都直接将压力传到数据库  
解决办法：  
1、缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY  
2、Bloom过滤或RoaringBitmap判断KEY是否存在  
3、完全以缓存为准，使用延迟异步加载的策略2，这样就不会触发更新  

缓存击穿：某个KEY失效的时候，正好有大量并发请求访问这个KEY  
解决办法：  
1、KEY的更新操作添加全局互斥锁  
2、完全以缓存为准，使用延迟异步加载的策略2，这样就不会触发更新  

缓存雪崩：当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数据库压力过大甚至宕机  
解决办法：
1、更新策略在时间上做到比较均匀  
2、使用的热数据尽量分散到不同的机器上  
3、多台机器做主从复制或者多副本，实现高可用  
4、实现熔断限流机制，对系统进行负载能力控制  

Redis是单线程还是多线程  
IO线程：  
redis6之前，单线程  
redis6之后，多线程  
内存处理线程：单线程  

## 分布式消息队列
MQ优势：  
异步通信：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作  
系统解耦：系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成  
削峰平谷：压力大的时候，缓冲部分请求消息，类似于背压处理  
可靠通信：提供多种消息模式、服务质量、顺序保障  
常见两种消息模式：点对点、发布订阅  

三代消息中间件：  
1、ActiveMQ/RabbitMQ  
2、Kafka/RocketMQ  
3、Apache Pulsar  

ActiveMQ主要功能：  
1.多种语言和协议编写客户端  
2.完全支持JMS1.1和J2EE1.4规范  
3.与Spring很好地集成，也支持常见J2EE服务器  
4.支持多种传输协议：in-VM,TCP,SSL,NIO,UDP,Jgroups,JXTA  
5.支持通过JDBC和journal提供高速的消息持久化  
6.实现了高性能的集群模式  

kafka基本概念  
1.Broker: Kafka集群包含一个或多个服务器，这种服务器被称为broker  
2.Topic: 每条发不到Kafka集群的消息都有一个类别，这个类别被称为Topic  
3.Partition: Partition是物理上的概念，每个Topic包含一个或多个Partition  
4.Producer: 负责发布消息到Kafka broker  
5.Consumer: 消息消费者，向Kafka broker读取消息的客户端  
6.Consumer Group: 每个Consumer属于一个特定的Consumer Group  